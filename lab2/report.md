# Lab2 实验报告

## 不同哈希策略的实现

在实现上，我对ascii和utf8字符串选用了同样的哈希函数，只不过解码方式，即读取`str[i]`的方式不同。
这个函数为简单但著名的djb2哈希算法[1]：`hash(i) = hash(i - 1) * 33 ^ str[i], hash(0)=5381`。

## 不同冲突解决策略的实现

### 双向平方试探

和线性试探策略不同，平方试探需要上次试探的加数，即需要储存在策略函数对象之中。幸运的是，框架代码已经为我们提供了`init`函数来重置状态，那么在函数体中只需要：

- 根据上一个状态计算出原字符串的哈希值
- 根据上一个状态更新当前状态
- 用当前状态计算出新的索引
- 对table_size取模（注意可能的负数）

即可完成计算。

### 公共溢出区

为了区分这个策略，我在`collision_strategy`中加入了`is_overflow`函数来进行判断。公共溢出策略将一部分空间作为发生哈希碰撞的值的储存区域（我使用了30%的总空间），并在哈希和碰撞处理时将剩余空间当作总空间进行取余。如果发生碰撞，则：

- 判断该索引是否为公共缓冲区
- 若是，则直接+1返回下一个位置
- 若不是，则返回缓冲区的第一个位置，即`table_size`

_(以上部分共384字)_

### 测试数据构造方法

数据生成器接受若干个参数，包括：

- 使用的数据集
- 插入与查询操作的数量
- 插入与查询操作的分布模式（先插入后查询或均匀分布）
- 查询操作中，已经插入的数据所占的比例（已经插入的数据更有可能发生哈希碰撞）

共两个测试集，每个测试集三组数据，参数分别为：

| 数据组 | 插入数量 | 查询数量 | 分布模式 | 已插入数据比例 |
| ------ | -------- | -------- | -------- | -------------- |
| 1      | 50000    | 150000   | 先插入   | 0.8            |
| 2      | 150000   | 50000    | 先插入   | 0.8            |
| 3      | 50000    | 150000   | 混合     | 0.8            |

_(以上部分共172字)_

### 结果分析

1. 无论是哪种编码方式，对于哈希函数本质上都是相同的，无谓就是对非负整数序列进行操作，因此差别不大。而utf8哈希看起来略好的原因，是其编码中含有相同的位，解码时将其去掉而强调了不同字符的差异性，令哈希碰撞的概率减小。
2. 在碰撞较多的情况下，双向平方法更优，而对于精心设计的哈希函数，实际上区别不大。原因在于，碰撞较多时，线性探测更容易形成“集群”而令探测长度增长。
3. 开放寻址更好。在碰撞很少的情况下，可以发挥其易于编写的优势。
4. 哈希表的性能依赖于哈希函数的均匀分布假设，若出现字符概率不均匀，可能造成碰撞增多而性能变差。
5. 若字符集确定且较小，可以使用前缀树结构，这样不需要任何数学运算即可确定字符串位置。

_(以上部分共294字)_